#include "/Engine/Private/Common.ush"
#include "/Engine/Private/VertexFactoryCommon.ush"

// Manual Vertex Fetch 相关
#define VF_ColorIndexMask_Index 0
#define VF_NumTexcoords_Index 1
#define FV_LightMapIndex_Index 2
#define VF_VertexOffset 3

/*
 * Vertex Shader需要使用相关结构体实现
 */

/*
 * VertexFactoryInput
 */
struct FVertexFactoryInput
{
	float4 Position : ATTRIBUTE0;

	float3	TangentX	: ATTRIBUTE1;
	// TangentZ.w contains sign of tangent basis determinant
	float4	TangentZ	: ATTRIBUTE2;
	
	/** Unique Vertex ID **/
	uint VertexId : SV_VertexID;
	/** This doesn`t use instance **/
	uint InstanceId	: SV_InstanceID;
};
struct FPositionOnlyVertexFactoryInput
{
	//PositionOnly必要项
	float4	Position	: ATTRIBUTE0;
	/** Unique Vertex ID **/
	uint VertexId : SV_VertexID;	
	/** This doesn`t use instance **/
	uint InstanceId	: SV_InstanceID;
};
struct FPositionAndNormalOnlyVertexFactoryInput
{
	float4  Position	: ATTRIBUTE0;
	float4	Normal		: ATTRIBUTE2;
	/** Unique Vertex ID **/
	uint    VertexId	: SV_VertexID;
	/** This doesn`t use instance **/
	uint InstanceId	: SV_InstanceID;
};
/*
 * VertexFactoryInput
 */

// VS to PS 插值数据
struct FVertexFactoryInterpolantsVSToPS 
{
#if NUM_TEX_COORD_INTERPOLATORS
	float4	TexCoords[(NUM_TEX_COORD_INTERPOLATORS+1)/2]	: TEXCOORD0;
#elif USE_PARTICLE_SUBUVS
	float4	TexCoords[1] : TEXCOORD0;
#endif
	
	half4 Color : COLOR0;
	
	//TANGENTTOWORLD_INTERPOLATOR_BLOCK (float4 TangentToWorld0 : TEXCOORD10_centroid;   float4	TangentToWorld2	: TEXCOORD11_centroid;)
	float4 TangentToWorld0 : TEXCOORD10_centroid;
	float4 TangentToWorld2 : TEXCOORD11_centroid;
	
};

#if NUM_TEX_COORD_INTERPOLATORS || USE_PARTICLE_SUBUVS
float2 GetUV(FVertexFactoryInterpolantsVSToPS Interpolants, int UVIndex)
{
	float4 UVVector = Interpolants.TexCoords[UVIndex / 2];
	return UVIndex % 2 ? UVVector.zw : UVVector.xy;
}

void SetUV(inout FVertexFactoryInterpolantsVSToPS Interpolants, int UVIndex, float2 InValue)
{
	FLATTEN
	if (UVIndex % 2)
	{
		Interpolants.TexCoords[UVIndex / 2].zw = InValue;
	}
	else
	{
		Interpolants.TexCoords[UVIndex / 2].xy = InValue;
	}
}
#endif

//顶点插值的中间数据
struct FVertexFactoryIntermediates
{
	/* The Position of the vertex in translated world space */
	float3 Position;

	/* vertex Color */
	half4 Color;

	half3x3 TangentToLocal;
	half3x3 TangentToWorld;
	half TangentToWorldSign;

	uint PrimitiveId;
};
/*
 * Vertex Shader需要使用相关结构体实现
 */
uint VertexFactoryGetInstanceIdLoadIndex(FVertexFactoryIntermediates Intermediates)
{
	return GetSceneDataIntermediates().InstanceIdLoadIndex;
}
//计算 TangentToLocal 矩阵
half3x3 CalcTangentToLocal(FVertexFactoryInput Input, inout float TangentSign)
{
#if MANUAL_VERTEX_FETCH
	half3 TangentInputX = CustomVF.VertexFetch_PackedTangentsBuffer[2 * (CustomVF.VertexFetch_Parameters[VF_VertexOffset] + Input.VertexId) + 0].xyz;
	half4 TangentInputZ = CustomVF.VertexFetch_PackedTangentsBuffer[2 * (CustomVF.VertexFetch_Parameters[VF_VertexOffset] + Input.VertexId) + 1].xyzw;
#else
	half3 TangentInputX = Input.TangentX;
	half4 TangentInputZ = Input.TangentZ;
#endif
	
	half3 TangentX = TangentInputX;
	half4 TangentZ = TangentInputZ;

	TangentSign = TangentZ.w;
	
	// derive the binormal by getting the cross product of the normal and tangent
	half3 TangentY = cross(TangentZ.xyz, TangentX) * TangentZ.w;

	// Recalculate TangentX off of the other two vectors
	// This corrects quantization error since TangentX was passed in as a quantized vertex input
	// The error shows up most in specular off of a mesh with a smoothed UV seam (normal is smooth, but tangents vary across the seam)
	half3x3 Result;
	Result[0] = cross(TangentY, TangentZ.xyz) * TangentZ.w;
	Result[1] = TangentY;
	Result[2] = TangentZ.xyz;

	return Result;
}
half3x3 CalcTangentToWorldNoScale(FVertexFactoryIntermediates Intermediates, half3x3 TangentToLocal)
{
	half3x3 LocalToWorld = GetLocalToWorld3x3();//half3x3 LocalToWorld = GetLocalToWorld3x3(Intermediates.PrimitiveId);
	half3 InvScale = GetPrimitiveData(Intermediates.PrimitiveId).InvNonUniformScale;
	LocalToWorld[0] *= InvScale.x;
	LocalToWorld[1] *= InvScale.y;
	LocalToWorld[2] *= InvScale.z;
	return mul(TangentToLocal , LocalToWorld);
}
half3x3 CalcTangentToWorld(FVertexFactoryIntermediates Intermediates, half3x3 TangentToLocal)
{
	half3x3 TangentToWorld = CalcTangentToWorldNoScale(Intermediates, TangentToLocal);
	return TangentToWorld;
}
float4 GetTangentToWorld2(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	return Interpolants.TangentToWorld2;
}
float4 GetTangentToWorld0(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	return Interpolants.TangentToWorld0;
}

//从 VertexInput 转换到中间数据格式
FVertexFactoryIntermediates GetVertexFactoryIntermediates(FVertexFactoryInput Input)
{
	FVertexFactoryIntermediates Intermediates;
	Intermediates.Position = Input.Position.xyz;

	float TangentSign = 1.0;
	Intermediates.TangentToLocal = CalcTangentToLocal(Input, TangentSign);
	Intermediates.TangentToWorld = CalcTangentToWorld(Intermediates, Intermediates.TangentToLocal);
	Intermediates.TangentToWorldSign = TangentSign /** GetPrimitiveData(Intermediates.PrimitiveId).InvNonUniformScale.w*/;	//TODO:这里需要再看一下
	
	Intermediates.Color = half4(1, 1, 1, 1);
	return Intermediates;
}
// 材质Pixel参数 , MaterialPixelParameters 从Material.ush中引入
FMaterialPixelParameters GetMaterialPixelParameters(FVertexFactoryInterpolantsVSToPS Interpolants, float4 SvPosition)
{
	FMaterialPixelParameters Result = MakeInitializedMaterialPixelParameters();
	
#if NUM_TEX_COORD_INTERPOLATORS //在Mateiral.ush中定义了
	UNROLL
	for (int CoordinateIndex = 0; CoordinateIndex < NUM_TEX_COORD_INTERPOLATORS; CoordinateIndex++)
	{
		Result.TexCoords[CoordinateIndex] = GetUV(Interpolants , CoordinateIndex);
	}
#endif	//NUM_MATERIAL_TEXCOORDS
	half3 TangentToWorld0 = GetTangentToWorld0(Interpolants).xyz;
	half4 TangentToWorld2 = GetTangentToWorld2(Interpolants);

	Result.TangentToWorld = AssembleTangentToWorld( TangentToWorld0, TangentToWorld2 );
	Result.VertexColor = Interpolants.Color;
	Result.TwoSidedSign = 1;
	return Result;
}
// 材质Vertex参数 , MaterialVertexParameters 从Material.ush中引入
FMaterialVertexParameters GetMaterialVertexParameters(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 WorldPosition, half3x3 TangentToLocal)
{
	FMaterialVertexParameters Result = MakeInitializedMaterialVertexParameters();
	Result.WorldPosition = WorldPosition;
	Result.VertexColor = Intermediates.Color;
	Result.TangentToWorld = mul(TangentToLocal , GetLocalToWorld3x3());

#if NUM_MATERIAL_TEXCOORDS //在Mateiral.ush中定义了
	const uint NumFetchTexCoords = CustomVF.VertexFetch_Parameters[VF_NumTexcoords_Index];
	UNROLL
	for (uint CoordinateIndex = 0; CoordinateIndex < NUM_MATERIAL_TEXCOORDS_VERTEX; CoordinateIndex++)
	{
		// Clamp coordinates to mesh's maximum as materials can request more than are available
		uint ClampedCoordinateIndex = min(CoordinateIndex, NumFetchTexCoords-1);
		Result.TexCoords[CoordinateIndex] = CustomVF.VertexFetch_TexCoordBuffer[NumFetchTexCoords * (CustomVF.VertexFetch_Parameters[VF_VertexOffset] + Input.VertexId) + ClampedCoordinateIndex];
	}
#endif	//NUM_MATERIAL_TEXCOORDS
	
	Result.PrimitiveId = Intermediates.PrimitiveId;
	return Result;
}

uint VertexFactoryGetViewIndex(FVertexFactoryIntermediates Intermediates)
{
	return 0; //GetSceneDataIntermediates(Intermediates).ViewIndex;
}

// 从VertexFactoryIntermediates中获取世界坐标
float4 VertexFactoryGetWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return TransformLocalToTranslatedWorld(Intermediates.Position);
}
// For depth-only pass (slope depth bias)
float4 VertexFactoryGetWorldPosition(FPositionAndNormalOnlyVertexFactoryInput Input)
{
	float4 Position = Input.Position;
#if VF_USE_PRIMITIVE_SCENE_DATA
	uint PrimitiveId = Input.PrimitiveId;
#else
	uint PrimitiveId = 0;
#endif

#if USE_INSTANCING
	return 0;//暂时未支持 Instance
#else
	return TransformLocalToTranslatedWorld(Position);
#endif
}
// For DepthOnlyVertexFactory
float4 VertexFactoryGetWorldPosition(FPositionOnlyVertexFactoryInput Input)
{
	float4 Position = Input.Position;
#if VF_USE_PRIMITIVE_SCENE_DATA
	uint PrimitiveId = Input.PrimitiveId;
#else
	uint PrimitiveId = 0;
#endif

#if USE_INSTANCING
	return 0;//暂时未支持 Instance
#else
	return TransformLocalToTranslatedWorld(Position);
#endif
}
float4 VertexFactoryGetRasterizedWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float4 InWorldPosition)
{
	return InWorldPosition;
}

void SetTangents(inout FVertexFactoryInterpolantsVSToPS Interpolants, float3 InTangentToWorld0, float3 InTangentToWorld2, float InTangentToWorldSign)
{
	Interpolants.TangentToWorld0 = float4(InTangentToWorld0,0);
	Interpolants.TangentToWorld2 = float4(InTangentToWorld2,InTangentToWorldSign);
}

// VS 最终插值到 PS 的数据
FVertexFactoryInterpolantsVSToPS VertexFactoryGetInterpolantsVSToPS(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, FMaterialVertexParameters VertexParameters)
{
	FVertexFactoryInterpolantsVSToPS Interpolants ;
#if NUM_TEX_COORD_INTERPOLATORS
	float2 CustomizedUVs[NUM_TEX_COORD_INTERPOLATORS];
	GetMaterialCustomizedUVs(VertexParameters, CustomizedUVs);
	GetCustomInterpolators(VertexParameters, CustomizedUVs);
	UNROLL
	for (int CoordinateIndex = 0; CoordinateIndex < NUM_TEX_COORD_INTERPOLATORS; CoordinateIndex++)
	{
		SetUV(Interpolants, CoordinateIndex, CustomizedUVs[CoordinateIndex]);
	}
#elif NUM_MATERIAL_TEXCOORDS_VERTEX == 0 && USE_PARTICLE_SUBUVS
	SetUV(Interpolants, 0, CustomVF.VertexFetch_TexCoordBuffer[CustomVF.VertexFetch_Parameters[VF_NumTexcoords_Index] * (CustomVF.VertexFetch_Parameters[VF_VertexOffset] + Input.VertexId)]);
#endif
	
	Interpolants.Color = VertexParameters.VertexColor;

	SetTangents(Interpolants, Intermediates.TangentToWorld[0], Intermediates.TangentToWorld[2], Intermediates.TangentToWorldSign);
	
	return Interpolants;
}
//返回上一帧的位置，先直接返回WorldPosition
float4 VertexFactoryGetPreviousWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return VertexFactoryGetWorldPosition(Input , Intermediates);
}

half3x3 VertexFactoryGetTangentToLocal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return Intermediates.TangentToLocal;;
}
float3 VertexFactoryGetWorldNormal(FVertexFactoryInput Input , FVertexFactoryIntermediates Intermediates)
{
	return Intermediates.TangentToWorld[2];
}
float3 VertexFactoryGetWorldNormal(FPositionAndNormalOnlyVertexFactoryInput Input)
{
	return Input.Normal.xyz;
}

//一些必要的函数
float4 VertexFactoryGetTranslatedPrimitiveVolumeBounds(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	return 0;
}
uint VertexFactoryGetPrimitiveId(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	return 0;
}